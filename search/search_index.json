{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to mesa-frames \ud83d\ude80","text":"<p>mesa-frames is an extension of the mesa framework, designed for complex simulations with thousands of agents. By storing agents in a DataFrame, mesa-frames significantly enhances the performance and scalability of mesa, while maintaining a similar syntax.</p> <p>You can get a model which is multiple orders of magnitude faster based on the number of agents - the more agents, the faster the relative performance.</p>"},{"location":"#why-dataframes","title":"Why DataFrames? \ud83d\udcca","text":"<p>DataFrames are optimized for simultaneous operations through SIMD processing. Currently, mesa-frames supports the library:</p> <ul> <li>Polars: A new DataFrame library with a Rust backend, offering innovations like Apache Arrow memory format and support for larger-than-memory DataFrames.</li> </ul>"},{"location":"#performance-boost","title":"Performance Boost \ud83c\udfce\ufe0f","text":"<p>Check out our performance graphs comparing mesa and mesa-frames for the Boltzmann Wealth model:</p> <p></p> <p></p>"},{"location":"#quick-start","title":"Quick Start \ud83d\ude80","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#installing-from-pypi","title":"Installing from PyPI","text":"<pre><code>pip install mesa-frames\n</code></pre>"},{"location":"#installing-from-source","title":"Installing from Source","text":"<pre><code>git clone https://github.com/projectmesa/mesa-frames.git\ncd mesa_frames\npip install -e .\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Here's a quick example of how to create a model using mesa-frames:</p> <pre><code>from mesa_frames import AgentSetPolars, ModelDF\nimport polars as pl\n\nclass MoneyAgentPolars(AgentSetPolars):\n    def __init__(self, n: int, model: ModelDF):\n        super().__init__(model)\n        self += pl.DataFrame(\n            {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}\n        )\n\n    def step(self) -&gt; None:\n        self.do(\"give_money\")\n\n    def give_money(self):\n        # ... (implementation details)\n\nclass MoneyModelDF(ModelDF):\n    def __init__(self, N: int):\n        super().__init__()\n        self.agents += MoneyAgentPolars(N, self)\n\n    def step(self):\n        self.agents.do(\"step\")\n\n    def run_model(self, n):\n        for _ in range(n):\n            self.step()\n</code></pre>"},{"location":"#whats-next","title":"What's Next? \ud83d\udd2e","text":"<ul> <li>API refinement for seamless transition from mesa</li> <li>Support for mesa functions</li> <li>Multiple other spaces: GeoGrid, ContinuousSpace, Network...</li> <li>Additional backends: Dask, cuDF (GPU), Dask-cuDF (GPU)...</li> <li>More examples: Schelling model, ...</li> <li>Automatic vectorization of existing mesa models</li> <li>Backend-agnostic AgentSet class</li> </ul>"},{"location":"#get-involved","title":"Get Involved! \ud83e\udd1d","text":"<p>mesa-frames is in its early stages, and we welcome your feedback and contributions! Check out our GitHub repository to get started.</p>"},{"location":"#license","title":"License","text":"<p>mesa-frames is available under the MIT License. See the LICENSE file for full details.</p>"},{"location":"contributing/","title":"Contributing to mesa-frames \ud83d\ude80","text":"<p>Thank you for taking the time to contribute to mesa-frames! Since the project is still in its early stages, we warmly welcome contributions that will help shape its development. \ud83c\udf89</p> <p>For a more general and comprehensive guide, please refer to mesa's main contribution guidelines. \ud83d\udcdc</p>"},{"location":"contributing/#project-roadmap","title":"Project Roadmap \ud83d\uddfa\ufe0f","text":"<p>Before contributing, we recommend reviewing our roadmap file to understand the project's current priorities, upcoming features, and long-term vision. This will help ensure your contributions align with the project's direction.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute \ud83d\udca1","text":""},{"location":"contributing/#1-prerequisite-installations","title":"1. Prerequisite Installations \u2699\ufe0f","text":"<p>Before you begin contributing, ensure that you have the necessary tools installed:</p> <ul> <li>Install Python (at least the version specified in <code>requires-python</code> of <code>pyproject.toml</code>). \ud83d\udc0d</li> <li>We recommend using a virtual environment manager like:</li> <li>Astral's UV \ud83c\udf1f</li> <li>Hatch \ud83c\udfd7\ufe0f</li> <li>Install pre-commit to enforce code quality standards before pushing changes:</li> <li>Pre-commit installation guide \u2705</li> <li>More about pre-commit hooks</li> <li>If using VS Code, consider installing these extensions to automatically enforce formatting:</li> <li>Ruff \u2013 Python linting &amp; formatting \ud83d\udc3e</li> <li>Markdownlint \u2013 Markdown linting (for documentation) \u270d\ufe0f</li> <li>Git Hooks \u2013 Automatically runs &amp; visualizes pre-commit hooks \ud83d\udd17</li> </ul>"},{"location":"contributing/#2-contribution-process","title":"2. Contribution Process \ud83d\udee0\ufe0f","text":""},{"location":"contributing/#step-1-choose-an-issue","title":"Step 1: Choose an Issue \ud83d\udccc","text":"<ul> <li>Pick an existing issue or create a new one if necessary.</li> <li>Ensure that your contribution aligns with the project's goals.</li> </ul>"},{"location":"contributing/#step-2-set-up-your-local-repository","title":"Step 2: Set Up Your Local Repository \ud83d\udcbb","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork to your local machine:</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/mesa-frames.git\n</code></pre> <ol> <li>Create a new branch with a descriptive name:</li> </ol> <pre><code>git checkout -b feature-name\n</code></pre> <ol> <li>Prevent merge commit clutter by setting rebase mode:</li> </ol> <pre><code>git config pull.rebase true\n</code></pre>"},{"location":"contributing/#step-3-install-dependencies","title":"Step 3: Install Dependencies \ud83d\udce6","text":"<p>It is recommended to set up a virtual environment before installing dependencies.</p> <ul> <li>Using UV:</li> </ul> <pre><code>uv add --dev .[dev]\n</code></pre> <ul> <li>Using Hatch:</li> </ul> <pre><code>hatch env create dev\n</code></pre> <ul> <li>Using Standard Python:</li> </ul> <pre><code>python3 -m venv myenv\nsource myenv/bin/activate  # macOS/Linux\nmyenv\\Scripts\\activate    # Windows\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#step-4-make-and-commit-changes","title":"Step 4: Make and Commit Changes \u2728","text":"<ol> <li>Make necessary edits and save the code.</li> <li>Add and commit your changes with meaningful commit messages:</li> </ol> <pre><code>git add FILE_NAME\ngit commit -m \"Fix issue X: Brief description of the fix\"\n</code></pre> <ul> <li>Keep commits small and focused on a single logical change.</li> <li>Follow Tim Pope\u2019s commit message guidelines. \ud83d\udcdd</li> </ul>"},{"location":"contributing/#step-5-code-quality-and-testing","title":"Step 5: Code Quality and Testing \u2705","text":"<ul> <li>Run pre-commit hooks to enforce code quality standards:</li> </ul> <pre><code>pre-commit run\n</code></pre> <ul> <li>Run tests to ensure your contribution does not break functionality:</li> </ul> <pre><code>pytest --cov\n</code></pre> <ul> <li> <p>If using UV: <code>uv run pytest --cov</code></p> </li> <li> <p>Optional: Enable runtime type checking during development for enhanced type safety:</p> </li> </ul> <pre><code>MESA_FRAMES_RUNTIME_TYPECHECKING=1 uv run pytest --cov\n</code></pre> <p>!!! tip \"Automatically Enabled\"       Runtime type checking is automatically enabled in these scenarios:</p> <pre><code>  - **Hatch development environment** (`hatch shell dev`)\n  - **VS Code debugging** (when using the debugger)\n  - **VS Code testing** (when running tests through VS Code's testing interface)\n\n  No manual setup needed in these environments!\n</code></pre> <p>For more details on runtime type checking, see the Development Guidelines.</p>"},{"location":"contributing/#step-6-documentation-updates-if-needed","title":"Step 6: Documentation Updates (If Needed) \ud83d\udcd6","text":"<ul> <li>If you add a new feature, update the documentation accordingly.</li> <li>We use MKDocs for documentation:</li> <li>Modify or create markdown files in the <code>docs/</code> folder.</li> <li> <p>Preview your changes by running:</p> <pre><code>mkdocs serve\nuv run mkdocs serve #If using uv\n</code></pre> </li> <li> <p>Open <code>http://127.0.0.1:8000</code> in your browser to verify documentation updates.</p> </li> </ul>"},{"location":"contributing/#step-7-push-changes-and-open-a-pull-request-pr","title":"Step 7: Push Changes and Open a Pull Request (PR) \ud83d\ude80","text":"<ol> <li>Push your changes to your fork:</li> </ol> <pre><code>git push origin feature-name\n</code></pre> <ol> <li>Open a pull request (PR):</li> <li>Follow GitHub\u2019s PR guide.</li> <li>Link the issue you are solving in the PR description.</li> </ol> <p>Thank you again for your contribution! \ud83c\udf89</p>"},{"location":"roadmap/","title":"Roadmap \ud83d\uddfa\ufe0f","text":"<p>This document outlines the development roadmap for the mesa-frames project. It provides insights into our current priorities, upcoming features, and long-term vision.</p>"},{"location":"roadmap/#010-stable-release-goals","title":"0.1.0 Stable Release Goals \ud83c\udfaf","text":""},{"location":"roadmap/#1-transitioning-polars-implementation-from-eager-api-to-lazy-api","title":"1. Transitioning polars implementation from eager API to lazy API","text":"<p>One of our major priorities was to move from pandas to polars as the primary dataframe backend. This transition was motivated by performance considerations. Now we should transition to using the lazily evaluated version of polars.</p> <p>Related issues: #10: GPU integration: Dask, cuda (cudf) and RAPIDS (Polars), #89: Investigate using Ibis for the common interface library to any DF backend, #52: Use of LazyFrames for Polars implementation</p>"},{"location":"roadmap/#progress-and-next-steps","title":"Progress and Next Steps","text":"<ul> <li>We are exploring Ibis or narwhals as a common interface library that could support multiple backends (Polars, DuckDB, Spark etc.), but since most of the development is currently in polars, we will currently continue using Polars.</li> <li>We're transitioning to the lazy API, mainly in order to use GPU acceleration</li> </ul>"},{"location":"roadmap/#2-handling-concurrency-management","title":"2. Handling Concurrency Management","text":"<p>A critical aspect of agent-based models is efficiently managing concurrent agent movements, especially when multiple agents attempt to move to the same location simultaneously. We aim to implement abstractions that handle these concurrency conditions automatically.</p> <p>Related issues: #108: Adding abstraction of optimal agent movement, #48: Emulate RandomActivation with DataFrame.rolling</p>"},{"location":"roadmap/#sugarscape-example-of-concurrency-issues","title":"Sugarscape Example of Concurrency Issues","text":"<p>Testing with many potential collisions revealed a specific issue:</p> <p>Problem scenario:</p> <ul> <li>Consider two agents targeting the same cell:</li> <li>A mid-priority agent (higher in the agent order)</li> <li>A low-priority agent (lower in the agent order)</li> <li>The mid-priority agent has low preference for the cell</li> <li>The low-priority agent has high preference for the cell</li> <li>Without accounting for priority:</li> <li>The mid-priority agent's best moves kept getting \"stolen\" by higher priority agents</li> <li>This forced it to resort to lower preference target cells</li> <li>However, these lower preference cells were often already taken by lower priority agents in previous iterations</li> </ul> <p>Solution approach:</p> <ul> <li>Implement a \"priority\" count to ensure that each action is \"legal\"</li> <li>This prevents race conditions but requires recomputing the priority at each iteration</li> <li>Current implementation may be slower than Numba due to this overhead</li> <li>After the Ibis refactoring, we can investigate if lazy evaluation can help mitigate this performance issue</li> </ul> <p>The Sugarscape example demonstrates the need for this abstraction, as multiple agents often attempt to move to the same cell simultaneously. By generalizing this functionality, we can eliminate the need for users to implement complex conflict resolution logic repeatedly.</p>"},{"location":"roadmap/#progress-and-next-steps_1","title":"Progress and Next Steps","text":"<ul> <li>Create utility functions in <code>DiscreteSpaceDF</code> and <code>AgentContainer</code> to move agents optimally based on specified attributes</li> <li>Provide built-in resolution strategies for common concurrency scenarios</li> <li>Ensure the implementation works efficiently with the vectorized approach of mesa-frames</li> </ul>"},{"location":"roadmap/#additional-010-goals","title":"Additional 0.1.0 Goals","text":"<ul> <li>Complete core API stabilization</li> <li>Completely mirror mesa's functionality</li> <li>Improve documentation and examples</li> <li>Address outstanding bugs and performance issues</li> </ul>"},{"location":"roadmap/#beyond-010","title":"Beyond 0.1.0","text":"<p>Future roadmap items will be added as the project evolves and new priorities emerge.</p> <p>We welcome community feedback on our roadmap! Please open an issue if you have suggestions or would like to contribute to any of these initiatives.</p>"},{"location":"development/","title":"Development Guidelines","text":""},{"location":"development/#runtime-type-checking","title":"Runtime Type Checking \ud83d\udd0d","text":"<p>mesa-frames includes optional runtime type checking using beartype for development and debugging purposes. This feature helps catch type-related errors early during development and testing.</p> <p>Automatically Enabled</p> <p>Runtime type checking is automatically enabled in the following scenarios:</p> <ul> <li>Hatch development environment (<code>hatch shell dev</code>) \u2014 via <code>pyproject.toml</code> configuration</li> <li>VS Code debugging \u2014 when using the debugger (<code>F5</code> or \"Python Debugger: Current File\")</li> <li>VS Code testing \u2014 when running tests through VS Code's testing interface</li> </ul> <p>No manual setup required in these environments!</p>"},{"location":"development/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"development/#option-1-hatch-development-environment-recommended","title":"Option 1: Hatch Development Environment (Recommended)","text":"<p>The easiest way to enable runtime type checking is to use Hatch's development environment:</p> <pre><code># Enter the development environment (auto-enables runtime type checking)\nhatch shell dev\n\n# Verify it's enabled\npython -c \"import os; print('Runtime type checking:', os.getenv('MESA_FRAMES_RUNTIME_TYPECHECKING'))\"\n# \u2192 Runtime type checking: true\n</code></pre>"},{"location":"development/#option-2-manual-environment-variable","title":"Option 2: Manual Environment Variable","text":"<p>For other development setups, you can manually enable runtime type checking:</p> <p>Runtime type checking can be enabled by setting the <code>MESA_FRAMES_RUNTIME_TYPECHECKING</code> environment variable:</p> <pre><code>export MESA_FRAMES_RUNTIME_TYPECHECKING=1\n# or\nexport MESA_FRAMES_RUNTIME_TYPECHECKING=true\n# or\nexport MESA_FRAMES_RUNTIME_TYPECHECKING=yes\n</code></pre>"},{"location":"development/#usage-examples","title":"Usage Examples","text":"<p>Automatic Activation</p> <p>If you're using Hatch dev environment, VS Code debugging, or VS Code testing, runtime type checking is already enabled automatically. The examples below are for manual activation in other scenarios.</p>"},{"location":"development/#for-development-and-testing","title":"For Development and Testing","text":"<pre><code># Enable runtime type checking for testing\nMESA_FRAMES_RUNTIME_TYPECHECKING=1 uv run pytest\n\n# Enable runtime type checking for running scripts\nMESA_FRAMES_RUNTIME_TYPECHECKING=1 uv run python your_script.py\n</code></pre>"},{"location":"development/#in-your-ide-or-development-environment","title":"In Your IDE or Development Environment","text":"<p>VS Code (Already Configured):</p> <ul> <li>Debugging: Runtime type checking is automatically enabled when using VS Code's debugger</li> <li>Testing: Automatically enabled when running tests through VS Code's testing interface</li> <li> <p>Manual override: You can also add it manually in <code>.vscode/settings.json</code>:</p> <pre><code>{\n    \"python.env\": {\n        \"MESA_FRAMES_RUNTIME_TYPECHECKING\": \"1\"\n    }\n}\n</code></pre> </li> </ul> <p>PyCharm: In your run configuration, add the environment variable:</p> <pre><code>MESA_FRAMES_RUNTIME_TYPECHECKING=1\n</code></pre>"},{"location":"development/#how-it-works","title":"How It Works","text":"<p>When enabled, the runtime type checking system:</p> <ol> <li>Automatically instruments all mesa-frames packages with beartype decorators</li> <li>Validates function arguments and return values at runtime</li> <li>Provides detailed error messages when type mismatches occur</li> <li>Helps catch type-related bugs during development</li> </ol>"},{"location":"development/#requirements","title":"Requirements","text":"<p>Runtime type checking requires the optional <code>beartype</code> dependency:</p> <pre><code># Install beartype for runtime type checking\nuv add beartype\n# or\npip install beartype\n</code></pre> <p>Optional Dependency</p> <p>If <code>beartype</code> is not installed and runtime type checking is enabled, mesa-frames will issue a warning and continue without type checking.</p>"},{"location":"development/#performance-considerations","title":"Performance Considerations","text":"<p>Development Only</p> <p>Runtime type checking adds significant overhead and should only be used during development and testing. Do not enable it in production environments.</p> <p>The overhead includes:</p> <ul> <li>Function call interception and validation</li> <li>Type checking computations at runtime</li> <li>Memory usage for type checking infrastructure</li> </ul>"},{"location":"development/#when-to-use-runtime-type-checking","title":"When to Use Runtime Type Checking","text":"<p>\u2705 Automatically enabled (recommended):</p> <ul> <li>Hatch development environment (<code>hatch shell dev</code>)</li> <li>VS Code debugging sessions</li> <li>VS Code test execution</li> <li>Contributing to mesa-frames development</li> </ul> <p>\u2705 Manual activation (when needed):</p> <ul> <li>Development and debugging in other IDEs</li> <li>Writing new features outside VS Code</li> <li>Running unit tests from command line</li> <li>Troubleshooting type-related issues</li> </ul> <p>\u274c Not recommended for:</p> <ul> <li>Production deployments</li> <li>Performance benchmarking</li> <li>Large-scale simulations</li> <li>Final model runs</li> </ul>"},{"location":"development/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues with runtime type checking:</p> <ol> <li>Check beartype installation:</li> </ol> <pre><code>uv run python -c \"import beartype; print(beartype.__version__)\"\n</code></pre> <ol> <li>Verify environment variable:</li> </ol> <pre><code>echo $MESA_FRAMES_RUNTIME_TYPECHECKING\n</code></pre> <ol> <li>For automatic configurations:</li> <li>Hatch dev: Ensure you're in the dev environment (<code>hatch shell dev</code>)</li> <li>VS Code debugging: Check that the debugger configuration in <code>.vscode/launch.json</code> includes the environment variable</li> <li> <p>VS Code testing: Verify that <code>.env.test</code> file exists and contains <code>MESA_FRAMES_RUNTIME_TYPECHECKING=true</code></p> </li> <li> <p>Check for warnings in your application logs</p> </li> <li> <p>Disable temporarily if needed:</p> </li> </ol> <pre><code>unset MESA_FRAMES_RUNTIME_TYPECHECKING\n</code></pre> <p>Pro Tip</p> <p>Runtime type checking is particularly useful when developing custom AgentSet implementations or working with complex DataFrame operations where type safety is crucial.</p>"},{"location":"user-guide/0_getting-started/","title":"Getting Started \ud83d\ude80","text":""},{"location":"user-guide/0_getting-started/#main-concepts","title":"Main Concepts \ud83e\udde0","text":""},{"location":"user-guide/0_getting-started/#dataframe-based-object-oriented-framework","title":"DataFrame-Based Object-Oriented Framework \ud83d\udcca","text":"<p>Unlike traditional mesa models where each agent is an individual Python object, mesa-frames stores all agents of a particular type in a single DataFrame. We operate only at the AgentSet level.</p> <p>This approach allows for:</p> <ul> <li>Efficient memory usage</li> <li>Improved performance through vectorized operations on agent attributes (This is what makes <code>mesa-frames</code> fast)</li> </ul> <p>Objects can be easily subclassed to respect mesa's object-oriented philosophy.</p>"},{"location":"user-guide/0_getting-started/#vectorized-operations","title":"Vectorized Operations \u26a1","text":"<p>mesa-frames leverages the power of vectorized operations provided by DataFrame libraries:</p> <ul> <li>Operations are performed on entire columns of data at once</li> <li>This approach is significantly faster than iterating over individual agents</li> <li>Complex behaviors can be expressed in fewer lines of code</li> </ul> <p>You should never use loops to iterate through your agents. Instead, use vectorized operations and implemented methods. If you need to loop, loop through vectorized operations (see the advanced tutorial SugarScape IG for more information).</p> <p>It's important to note that in traditional <code>mesa</code> models, the order in which agents are activated can significantly impact the results of the model (see Comer, 2014). <code>mesa-frames</code>, by default, doesn't have this issue as all agents are processed simultaneously. However, this comes with the trade-off of needing to carefully implement conflict resolution mechanisms when sequential processing is required. We'll discuss how to handle these situations later in this guide.</p> <p>Check out these resources to understand vectorization and why it speeds up the code:</p> <ul> <li>What is vectorization?</li> <li>Vectorization Explained, Step by Step</li> </ul> <p>Here's a comparison between mesa-frames and mesa:</p> mesa-framesmesa <pre><code>class MoneyAgentPolarsConcise(AgentSetPolars):\n    # initialization...\n    def give_money(self):\n        # Active agents are changed to wealthy agents\n        self.select(self.wealth &gt; 0)\n\n        # Receiving agents are sampled (only native expressions currently supported)\n        other_agents = self.agents.sample(\n            n=len(self.active_agents), with_replacement=True\n        )\n\n        # Wealth of wealthy is decreased by 1\n        self[\"active\", \"wealth\"] -= 1\n\n        # Compute the income of the other agents (only native expressions currently supported)\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n\n        # Add the income to the other agents\n        self[new_wealth, \"wealth\"] += new_wealth[\"len\"]\n</code></pre> <pre><code>class MoneyAgent(mesa.Agent):\n    # initialization...\n    def give_money(self):\n        # Verify agent has some wealth\n        if self.wealth &gt; 0:\n            other_agent = self.random.choice(self.model.agents)\n            if other_agent is not None:\n                other_agent.wealth += 1\n                self.wealth -= 1\n</code></pre> <p>As you can see, while in mesa you should iterate through all the agents' steps in the model class, here you execute the method once for all agents.</p>"},{"location":"user-guide/0_getting-started/#coming-from-mesa","title":"Coming from mesa \ud83d\udd00","text":"<p>If you're familiar with mesa, this guide will help you understand the key differences in code structure between mesa and mesa-frames.</p>"},{"location":"user-guide/0_getting-started/#agent-representation","title":"Agent Representation \ud83d\udc65","text":"<ul> <li>mesa: Each agent is an individual object instance. Methods are defined for individual agents and called on each agent.</li> <li>mesa-frames: Agents are rows in a DataFrame, grouped into AgentSets. Methods are defined for AgentSets and operate on all agents simultaneously.</li> </ul> mesa-framesmesa <pre><code>class MoneyAgentSet(AgentSetPolars):\n    def __init__(self, n, model):\n        super().__init__(model)\n        self += pl.DataFrame({\n            \"unique_id\": pl.arange(n),\n            \"wealth\": pl.ones(n)\n            })\n    def step(self):\n        givers = self.wealth &gt; 0\n        receivers = self.agents.sample(n=len(self.active_agents))\n        self[givers, \"wealth\"] -= 1\n        new_wealth = receivers.groupby(\"unique_id\").count()\n        self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"count\"]\n</code></pre> <pre><code>class MoneyAgent(Agent):\n    def __init__(self, unique_id, model):\n        super().__init__(unique_id, model)\n        self.wealth = 1\n\n    def step(self):\n        if self.wealth &gt; 0:\n            other_agent = self.random.choice(self.model.schedule.agents)\n            other_agent.wealth += 1\n            self.wealth -= 1\n</code></pre>"},{"location":"user-guide/0_getting-started/#model-structure","title":"Model Structure \ud83c\udfd7\ufe0f","text":"<ul> <li>mesa: Models manage individual agents and use a scheduler.</li> <li>mesa-frames: Models manage AgentSets and directly control the simulation flow.</li> </ul> mesa-framesmesa <pre><code>class MoneyModel(ModelDF):\n    def __init__(self, N):\n        super().__init__()\n        self.agents += MoneyAgentSet(N, self)\n\n    def step(self):\n        self.agents.do(\"step\")\n</code></pre> <pre><code>class MoneyModel(Model):\n    def __init__(self, N):\n        self.num_agents = N\n        self.schedule = RandomActivation(self)\n        for i in range(self.num_agents):\n            a = MoneyAgent(i, self)\n            self.schedule.add(a)\n\n    def step(self):\n        self.schedule.step()\n</code></pre>"},{"location":"user-guide/0_getting-started/#transition-tips","title":"Transition Tips \ud83d\udca1","text":"<ol> <li>Think in Sets \ud83c\udfad: Instead of individual agents, think about operations on groups of agents.</li> <li>Leverage DataFrame Operations \ud83d\udee0\ufe0f: Familiarize yourself with Polars operations for efficient agent manipulation.</li> <li>Vectorize Logic \ud83d\ude85: Convert loops and conditionals to vectorized operations where possible.</li> <li>Use AgentSets \ud83d\udce6: Group similar agents into AgentSets instead of creating many individual agent classes.</li> </ol>"},{"location":"user-guide/0_getting-started/#handling-race-conditions","title":"Handling Race Conditions \ud83c\udfc1","text":"<p>When simultaneous activation is not possible, you need to handle race conditions carefully. There are two main approaches:</p> <ol> <li> <p>Custom UDF with Numba \ud83d\udd27: Use a custom User Defined Function (UDF) with Numba for efficient sequential processing.</p> </li> <li> <p>Polars UDF Guide</p> </li> <li> <p>Looping Mechanism \ud83d\udd01: Implement a looping mechanism on vectorized operations.</p> </li> </ol> <p>For a more detailed implementation of handling race conditions, please refer to the <code>examples/sugarscape-ig</code> in the mesa-frames repository. This example demonstrates how to implement the Sugarscape model with instantaneous growback, which requires careful handling of sequential agent actions.</p>"},{"location":"user-guide/1_classes/","title":"Classes \ud83d\udcda","text":""},{"location":"user-guide/1_classes/#agentsetdf","title":"AgentSetDF \ud83d\udc65","text":"<p>To create your own AgentSetDF class, you need to subclass the AgentSetPolars class and make sure to call <code>super().__init__(model)</code>.</p> <p>Typically, the next step would be to populate the class with your agents. To do that, you need to add a DataFrame to the AgentSetDF. You can do <code>self += agents</code> or <code>self.add(agents)</code>, where <code>agents</code> is a DataFrame or something that could be passed to a DataFrame constructor, like a dictionary or lists of lists. You need to make sure your DataFrame has a 'unique_id' column and that the ids are unique across the model, otherwise you will get an error raised. In the DataFrame, you should also put any attribute of the agent you are using.</p> <p>How can you choose which agents should be in the same AgentSet? The idea is that you should minimize the missing values in the DataFrame (so they should have similar/same attributes) and mostly everybody should do the same actions.</p> <p>Example:</p> <pre><code>class MoneyAgent(AgentSetPolars):\n    def __init__(self, n: int, model: ModelDF):\n        super().__init__(model)\n        self.initial_wealth = pl.ones(n)\n        self += pl.DataFrame({\n            \"unique_id\": pl.arange(n),\n            \"wealth\": self.initial_wealth\n        })\n\n    def step(self):\n        self[\"wealth\"] = self[\"wealth\"] + self.random.integers(n)\n</code></pre> <p>You can access the underlying DataFrame where agents are stored with <code>self.agents</code>. This allows you to use DataFrame methods like <code>self.agents.sample</code> or <code>self.agents.group_by(\"wealth\")</code> and more.</p>"},{"location":"user-guide/1_classes/#modeldf","title":"ModelDF \ud83c\udfd7\ufe0f","text":"<p>To add your AgentSetDF to your ModelDF, you should also add it to the agents with <code>+=</code> or <code>add</code>.</p> <p>NOTE: ModelDF.agents are stored in a class which is entirely similar to AgentSetDF called AgentsDF. The API of the two are the same. If you try accessing AgentsDF.agents, you will get a dictionary of <code>[AgentSetDF, DataFrame]</code>.</p> <p>Example:</p> <pre><code>class EcosystemModel(ModelDF):\n    def __init__(self, n_prey, n_predators):\n        super().__init__()\n        self.agents += Preys(n_prey, self)\n        self.agents += Predators(n_predators, self)\n\n    def step(self):\n        self.agents.do(\"move\")\n        self.agents.do(\"hunt\")\n        self.prey.do(\"reproduce\")\n</code></pre>"},{"location":"user-guide/1_classes/#space-griddf","title":"Space: GridDF \ud83c\udf10","text":"<p>mesa-frames provides efficient implementations of spatial environments:</p> <ul> <li>Spatial operations (like moving agents) are vectorized for performance</li> </ul> <p>Example:</p> <pre><code>class GridWorld(ModelDF):\n    def __init__(self, width, height):\n        super().__init__()\n        self.space = GridPolars(self, (width, height))\n        self.agents += AgentSet(100, self)\n        self.space.place_to_empty(self.agents)\n</code></pre> <p>A continuous GeoSpace, NetworkSpace, and a collection to have multiple spaces in the models are in the works! \ud83d\udea7</p>"},{"location":"user-guide/2_introductory-tutorial/","title":"Introductory Tutorial","text":"In\u00a0[1]: Copied! <pre># !pip install mesa-frames mesa\n</pre> # !pip install mesa-frames mesa In\u00a0[2]: Copied! <pre>from mesa_frames import ModelDF, AgentSetPolars\n\n\nclass MoneyModelDF(ModelDF):\n    def __init__(self, N: int, agents_cls):\n        super().__init__()\n        self.n_agents = N\n        self.agents += agents_cls(N, self)\n\n    def step(self):\n        # Executes the step method for every agentset in self.agents\n        self.agents.do(\"step\")\n\n    def run_model(self, n):\n        for _ in range(n):\n            self.step()\n</pre> from mesa_frames import ModelDF, AgentSetPolars   class MoneyModelDF(ModelDF):     def __init__(self, N: int, agents_cls):         super().__init__()         self.n_agents = N         self.agents += agents_cls(N, self)      def step(self):         # Executes the step method for every agentset in self.agents         self.agents.do(\"step\")      def run_model(self, n):         for _ in range(n):             self.step() <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 from mesa_frames import ModelDF, AgentSetPolars\n      4 class MoneyModelDF(ModelDF):\n      5     def __init__(self, N: int, agents_cls):\n\nFile /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mesa_frames/__init__.py:63\n     55         import warnings\n     57         warnings.warn(\n     58             \"MESA_FRAMES_RUNTIME_TYPECHECKING is enabled but beartype is not installed.\",\n     59             ImportWarning,\n     60             stacklevel=2,\n     61         )\n---&gt; 63 from mesa_frames.concrete.agents import AgentsDF\n     64 from mesa_frames.concrete.agentset import AgentSetPolars\n     65 from mesa_frames.concrete.model import ModelDF\n\nFile /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mesa_frames/concrete/agents.py:56\n     53 import numpy as np\n     54 import polars as pl\n---&gt; 56 from mesa_frames.abstract.agents import AgentContainer, AgentSetDF\n     57 from mesa_frames.types_ import (\n     58     AgentMask,\n     59     AgnosticAgentMask,\n   (...)     64     Series,\n     65 )\n     68 class AgentsDF(AgentContainer):\n\nFile /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mesa_frames/abstract/agents.py:52\n     48 from typing import Any, Literal, Self, overload\n     50 from numpy.random import Generator\n---&gt; 52 from mesa_frames.abstract.mixin import CopyMixin, DataFrameMixin\n     53 from mesa_frames.types_ import (\n     54     AgentMask,\n     55     BoolSeries,\n   (...)     60     Series,\n     61 )\n     64 class AgentContainer(CopyMixin):\n\nFile /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mesa_frames/abstract/mixin.py:52\n     49 from copy import copy, deepcopy\n     50 from typing import Any, Literal, Self, overload\n---&gt; 52 from mesa_frames.types_ import (\n     53     BoolSeries,\n     54     DataFrame,\n     55     DataFrameInput,\n     56     Index,\n     57     Mask,\n     58     Series,\n     59 )\n     62 class CopyMixin(ABC):\n     63     \"\"\"A mixin class that provides a fast copy method for the class that inherits it.\"\"\"\n\nFile /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/mesa_frames/types_.py:8\n      6 from typing import Literal, Annotated, Union, Any\n      7 from collections.abc import Mapping\n----&gt; 8 from beartype.vale import IsEqual\n      9 import math\n     10 import polars as pl\n\nModuleNotFoundError: No module named 'beartype'</pre> In\u00a0[3]: Copied! <pre>import polars as pl\n\n\nclass MoneyAgentPolars(AgentSetPolars):\n    def __init__(self, n: int, model: ModelDF):\n        super().__init__(model)\n        self += pl.DataFrame(\n            {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}\n        )\n\n    def step(self) -&gt; None:\n        self.do(\"give_money\")\n\n    def give_money(self):\n        self.select(self.wealth &gt; 0)\n        other_agents = self.agents.sample(\n            n=len(self.active_agents), with_replacement=True\n        )\n        self[\"active\", \"wealth\"] -= 1\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n        self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"len\"]\n</pre> import polars as pl   class MoneyAgentPolars(AgentSetPolars):     def __init__(self, n: int, model: ModelDF):         super().__init__(model)         self += pl.DataFrame(             {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}         )      def step(self) -&gt; None:         self.do(\"give_money\")      def give_money(self):         self.select(self.wealth &gt; 0)         other_agents = self.agents.sample(             n=len(self.active_agents), with_replacement=True         )         self[\"active\", \"wealth\"] -= 1         new_wealth = other_agents.group_by(\"unique_id\").len()         self[new_wealth[\"unique_id\"], \"wealth\"] += new_wealth[\"len\"] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 4\n      1 import polars as pl\n----&gt; 4 class MoneyAgentPolars(AgentSetPolars):\n      5     def __init__(self, n: int, model: ModelDF):\n      6         super().__init__(model)\n\nNameError: name 'AgentSetPolars' is not defined</pre> In\u00a0[4]: Copied! <pre># Choose either MoneyAgentPandas or MoneyAgentPolars\nagent_class = MoneyAgentPolars\n\n# Create and run the model\nmodel = MoneyModelDF(1000, agent_class)\nmodel.run_model(100)\n\nwealth_dist = list(model.agents.agents.values())[0]\n# Print the final wealth distribution\nprint(wealth_dist.select(pl.col(\"wealth\")).describe())\n</pre> # Choose either MoneyAgentPandas or MoneyAgentPolars agent_class = MoneyAgentPolars  # Create and run the model model = MoneyModelDF(1000, agent_class) model.run_model(100)  wealth_dist = list(model.agents.agents.values())[0] # Print the final wealth distribution print(wealth_dist.select(pl.col(\"wealth\")).describe()) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 2\n      1 # Choose either MoneyAgentPandas or MoneyAgentPolars\n----&gt; 2 agent_class = MoneyAgentPolars\n      4 # Create and run the model\n      5 model = MoneyModelDF(1000, agent_class)\n\nNameError: name 'MoneyAgentPolars' is not defined</pre> <p>This output shows the statistical summary of the wealth distribution after 100 steps of the simulation with 1000 agents.</p> In\u00a0[5]: Copied! <pre>class MoneyAgentPolarsConcise(AgentSetPolars):\n    def __init__(self, n: int, model: ModelDF):\n        super().__init__(model)\n        ## Adding the agents to the agent set\n        # 1. Changing the agents attribute directly (not recommended, if other agents were added before, they will be lost)\n        \"\"\"self.agents = pl.DataFrame(\n            {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}\n        )\"\"\"\n        # 2. Adding the dataframe with add\n        \"\"\"self.add(\n            pl.DataFrame(\n                {\n                    \"unique_id\": pl.arange(n, eager=True),\n                    \"wealth\": pl.ones(n, eager=True),\n                }\n            )\n        )\"\"\"\n        # 3. Adding the dataframe with __iadd__\n        self += pl.DataFrame(\n            {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}\n        )\n\n    def step(self) -&gt; None:\n        # The give_money method is called\n        # self.give_money()\n        self.do(\"give_money\")\n\n    def give_money(self):\n        ## Active agents are changed to wealthy agents\n        # 1. Using the __getitem__ method\n        # self.select(self[\"wealth\"] &gt; 0)\n        # 2. Using the fallback __getattr__ method\n        self.select(self.wealth &gt; 0)\n\n        # Receiving agents are sampled (only native expressions currently supported)\n        other_agents = self.agents.sample(\n            n=len(self.active_agents), with_replacement=True\n        )\n\n        # Wealth of wealthy is decreased by 1\n        # 1. Using the __setitem__ method with self.active_agents mask\n        # self[self.active_agents, \"wealth\"] -= 1\n        # 2. Using the __setitem__ method with \"active\" mask\n        self[\"active\", \"wealth\"] -= 1\n\n        # Compute the income of the other agents (only native expressions currently supported)\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n\n        # Add the income to the other agents\n        # 1. Using the set method\n        \"\"\"self.set(\n            attr_names=\"wealth\",\n            values=pl.col(\"wealth\") + new_wealth[\"len\"],\n            mask=new_wealth,\n        )\"\"\"\n\n        # 2. Using the __setitem__ method\n        self[new_wealth, \"wealth\"] += new_wealth[\"len\"]\n\n\nclass MoneyAgentPolarsNative(AgentSetPolars):\n    def __init__(self, n: int, model: ModelDF):\n        super().__init__(model)\n        self += pl.DataFrame(\n            {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}\n        )\n\n    def step(self) -&gt; None:\n        self.do(\"give_money\")\n\n    def give_money(self):\n        ## Active agents are changed to wealthy agents\n        self.select(pl.col(\"wealth\") &gt; 0)\n\n        other_agents = self.agents.sample(\n            n=len(self.active_agents), with_replacement=True\n        )\n\n        # Wealth of wealthy is decreased by 1\n        self.agents = self.agents.with_columns(\n            wealth=pl.when(pl.col(\"unique_id\").is_in(self.active_agents[\"unique_id\"]))\n            .then(pl.col(\"wealth\") - 1)\n            .otherwise(pl.col(\"wealth\"))\n        )\n\n        new_wealth = other_agents.group_by(\"unique_id\").len()\n\n        # Add the income to the other agents\n        self.agents = (\n            self.agents.join(new_wealth, on=\"unique_id\", how=\"left\")\n            .fill_null(0)\n            .with_columns(wealth=pl.col(\"wealth\") + pl.col(\"len\"))\n            .drop(\"len\")\n        )\n</pre> class MoneyAgentPolarsConcise(AgentSetPolars):     def __init__(self, n: int, model: ModelDF):         super().__init__(model)         ## Adding the agents to the agent set         # 1. Changing the agents attribute directly (not recommended, if other agents were added before, they will be lost)         \"\"\"self.agents = pl.DataFrame(             {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}         )\"\"\"         # 2. Adding the dataframe with add         \"\"\"self.add(             pl.DataFrame(                 {                     \"unique_id\": pl.arange(n, eager=True),                     \"wealth\": pl.ones(n, eager=True),                 }             )         )\"\"\"         # 3. Adding the dataframe with __iadd__         self += pl.DataFrame(             {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}         )      def step(self) -&gt; None:         # The give_money method is called         # self.give_money()         self.do(\"give_money\")      def give_money(self):         ## Active agents are changed to wealthy agents         # 1. Using the __getitem__ method         # self.select(self[\"wealth\"] &gt; 0)         # 2. Using the fallback __getattr__ method         self.select(self.wealth &gt; 0)          # Receiving agents are sampled (only native expressions currently supported)         other_agents = self.agents.sample(             n=len(self.active_agents), with_replacement=True         )          # Wealth of wealthy is decreased by 1         # 1. Using the __setitem__ method with self.active_agents mask         # self[self.active_agents, \"wealth\"] -= 1         # 2. Using the __setitem__ method with \"active\" mask         self[\"active\", \"wealth\"] -= 1          # Compute the income of the other agents (only native expressions currently supported)         new_wealth = other_agents.group_by(\"unique_id\").len()          # Add the income to the other agents         # 1. Using the set method         \"\"\"self.set(             attr_names=\"wealth\",             values=pl.col(\"wealth\") + new_wealth[\"len\"],             mask=new_wealth,         )\"\"\"          # 2. Using the __setitem__ method         self[new_wealth, \"wealth\"] += new_wealth[\"len\"]   class MoneyAgentPolarsNative(AgentSetPolars):     def __init__(self, n: int, model: ModelDF):         super().__init__(model)         self += pl.DataFrame(             {\"unique_id\": pl.arange(n, eager=True), \"wealth\": pl.ones(n, eager=True)}         )      def step(self) -&gt; None:         self.do(\"give_money\")      def give_money(self):         ## Active agents are changed to wealthy agents         self.select(pl.col(\"wealth\") &gt; 0)          other_agents = self.agents.sample(             n=len(self.active_agents), with_replacement=True         )          # Wealth of wealthy is decreased by 1         self.agents = self.agents.with_columns(             wealth=pl.when(pl.col(\"unique_id\").is_in(self.active_agents[\"unique_id\"]))             .then(pl.col(\"wealth\") - 1)             .otherwise(pl.col(\"wealth\"))         )          new_wealth = other_agents.group_by(\"unique_id\").len()          # Add the income to the other agents         self.agents = (             self.agents.join(new_wealth, on=\"unique_id\", how=\"left\")             .fill_null(0)             .with_columns(wealth=pl.col(\"wealth\") + pl.col(\"len\"))             .drop(\"len\")         ) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 class MoneyAgentPolarsConcise(AgentSetPolars):\n      2     def __init__(self, n: int, model: ModelDF):\n      3         super().__init__(model)\n\nNameError: name 'AgentSetPolars' is not defined</pre> <p>Add Mesa implementation of MoneyAgent and MoneyModel classes to test Mesa performance</p> In\u00a0[6]: Copied! <pre>import mesa\nimport importlib.metadata\nfrom packaging import version\n\n\nclass MoneyAgent(mesa.Agent):\n    \"\"\"An agent with fixed initial wealth.\"\"\"\n\n    def __init__(self, model):\n        # Pass the parameters to the parent class.\n        super().__init__(model)\n\n        # Create the agent's variable and set the initial values.\n        self.wealth = 1\n\n    def step(self):\n        # Verify agent has some wealth\n        if self.wealth &gt; 0:\n            other_agent: MoneyAgent = self.model.random.choice(self.model.agents)\n            if other_agent is not None:\n                other_agent.wealth += 1\n                self.wealth -= 1\n\n\nclass MoneyModel(mesa.Model):\n    \"\"\"A model with some number of agents.\"\"\"\n\n    def __init__(self, N: int):\n        super().__init__()\n        self.num_agents = N\n        for i in range(N):\n            self.agents.add(MoneyAgent(self))\n\n    def step(self):\n        \"\"\"Advance the model by one step.\"\"\"\n        self.agents.shuffle_do(\"step\")\n\n    def run_model(self, n_steps) -&gt; None:\n        for _ in range(n_steps):\n            self.step()\n</pre> import mesa import importlib.metadata from packaging import version   class MoneyAgent(mesa.Agent):     \"\"\"An agent with fixed initial wealth.\"\"\"      def __init__(self, model):         # Pass the parameters to the parent class.         super().__init__(model)          # Create the agent's variable and set the initial values.         self.wealth = 1      def step(self):         # Verify agent has some wealth         if self.wealth &gt; 0:             other_agent: MoneyAgent = self.model.random.choice(self.model.agents)             if other_agent is not None:                 other_agent.wealth += 1                 self.wealth -= 1   class MoneyModel(mesa.Model):     \"\"\"A model with some number of agents.\"\"\"      def __init__(self, N: int):         super().__init__()         self.num_agents = N         for i in range(N):             self.agents.add(MoneyAgent(self))      def step(self):         \"\"\"Advance the model by one step.\"\"\"         self.agents.shuffle_do(\"step\")      def run_model(self, n_steps) -&gt; None:         for _ in range(n_steps):             self.step() <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 import mesa\n      2 import importlib.metadata\n      3 from packaging import version\n\nModuleNotFoundError: No module named 'mesa'</pre> In\u00a0[7]: Copied! <pre>import time\n\n\ndef run_simulation(model: MoneyModel | MoneyModelDF, n_steps: int):\n    start_time = time.time()\n    model.run_model(n_steps)\n    end_time = time.time()\n    return end_time - start_time\n\n\n# Compare mesa and mesa-frames implementations\nn_agents_list = [10**2, 10**3 + 1, 2 * 10**3]\nn_steps = 100\nprint(\"Execution times:\")\nfor implementation in [\n    \"mesa\",\n    \"mesa-frames (pl concise)\",\n    \"mesa-frames (pl native)\",\n]:\n    print(f\"---------------\\n{implementation}:\")\n    for n_agents in n_agents_list:\n        if implementation == \"mesa\":\n            ntime = run_simulation(MoneyModel(n_agents), n_steps)\n        elif implementation == \"mesa-frames (pl concise)\":\n            ntime = run_simulation(\n                MoneyModelDF(n_agents, MoneyAgentPolarsConcise), n_steps\n            )\n        elif implementation == \"mesa-frames (pl native)\":\n            ntime = run_simulation(\n                MoneyModelDF(n_agents, MoneyAgentPolarsNative), n_steps\n            )\n\n        print(f\"  Number of agents: {n_agents}, Time: {ntime:.2f} seconds\")\n    print(\"---------------\")\n</pre> import time   def run_simulation(model: MoneyModel | MoneyModelDF, n_steps: int):     start_time = time.time()     model.run_model(n_steps)     end_time = time.time()     return end_time - start_time   # Compare mesa and mesa-frames implementations n_agents_list = [10**2, 10**3 + 1, 2 * 10**3] n_steps = 100 print(\"Execution times:\") for implementation in [     \"mesa\",     \"mesa-frames (pl concise)\",     \"mesa-frames (pl native)\", ]:     print(f\"---------------\\n{implementation}:\")     for n_agents in n_agents_list:         if implementation == \"mesa\":             ntime = run_simulation(MoneyModel(n_agents), n_steps)         elif implementation == \"mesa-frames (pl concise)\":             ntime = run_simulation(                 MoneyModelDF(n_agents, MoneyAgentPolarsConcise), n_steps             )         elif implementation == \"mesa-frames (pl native)\":             ntime = run_simulation(                 MoneyModelDF(n_agents, MoneyAgentPolarsNative), n_steps             )          print(f\"  Number of agents: {n_agents}, Time: {ntime:.2f} seconds\")     print(\"---------------\") <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 4\n      1 import time\n----&gt; 4 def run_simulation(model: MoneyModel | MoneyModelDF, n_steps: int):\n      5     start_time = time.time()\n      6     model.run_model(n_steps)\n\nNameError: name 'MoneyModel' is not defined</pre>"},{"location":"user-guide/2_introductory-tutorial/#installation-if-running-in-colab","title":"Installation (if running in Colab)\u00b6","text":"<p>Run the following cell to install <code>mesa-frames</code> if you are using Google Colab.</p>"},{"location":"user-guide/2_introductory-tutorial/#introductory-tutorial-boltzmann-wealth-model-with-mesa-frames","title":"Introductory Tutorial: Boltzmann Wealth Model with mesa-frames \ud83d\udcb0\ud83d\ude80\u00b6","text":"<p>In this tutorial, we'll implement the Boltzmann Wealth Model using mesa-frames. This model simulates the distribution of wealth among agents, where agents randomly give money to each other.</p>"},{"location":"user-guide/2_introductory-tutorial/#setting-up-the-model","title":"Setting Up the Model \ud83c\udfd7\ufe0f\u00b6","text":"<p>First, let's import the necessary modules and set up our model class:</p>"},{"location":"user-guide/2_introductory-tutorial/#implementing-the-agentset","title":"Implementing the AgentSet \ud83d\udc65\u00b6","text":"<p>Now, let's implement our <code>MoneyAgentSet</code> using polars backends.</p>"},{"location":"user-guide/2_introductory-tutorial/#running-the-model","title":"Running the Model \u25b6\ufe0f\u00b6","text":"<p>Now that we have our model and agent set defined, let's run a simulation:</p>"},{"location":"user-guide/2_introductory-tutorial/#performance-comparison","title":"Performance Comparison \ud83c\udfce\ufe0f\ud83d\udca8\u00b6","text":"<p>One of the key advantages of mesa-frames is its performance with large numbers of agents. Let's compare the performance of mesa and polars:</p>"},{"location":"user-guide/2_introductory-tutorial/#conclusion","title":"Conclusion \ud83c\udf89\u00b6","text":"<ul> <li>All mesa-frames implementations significantly outperform the original mesa implementation. \ud83c\udfc6</li> <li>The native implementation for Polars shows better performance than their concise counterparts. \ud83d\udcaa</li> <li>The Polars native implementation shows the most impressive speed-up, ranging from 10.86x to 17.60x faster than mesa! \ud83d\ude80\ud83d\ude80\ud83d\ude80</li> <li>The performance advantage of mesa-frames becomes more pronounced as the number of agents increases. \ud83d\udcc8</li> </ul>"},{"location":"user-guide/3_advanced-tutorial/","title":"Advanced Tutorial: SugarScape with Instantaneous Growback \ud83c\udf6c\ud83d\udd04","text":"<p>Work in Progress \ud83d\udea7</p> <p>This tutorial is coming soon! \ud83d\udd1c\u2728 In the meantime, you can check out the code in the <code>examples/sugarscape-ig</code> directory of the mesa-frames repository.</p>"},{"location":"user-guide/4_benchmarks/","title":"Performance Boost \ud83c\udfce\ufe0f\ud83d\udca8","text":"<p>mesa-frames offers significant performance improvements over the original mesa framework. Here are some benchmark results for different models:</p>"},{"location":"user-guide/4_benchmarks/#boltzmann-wealth-model","title":"Boltzmann Wealth Model \ud83d\udcb0","text":"<p>View the benchmark script</p>"},{"location":"user-guide/4_benchmarks/#comparison-with-mesa","title":"Comparison with mesa","text":""},{"location":"user-guide/4_benchmarks/#comparison-of-mesa-frames-implementations","title":"Comparison of mesa-frames implementations","text":""},{"location":"user-guide/4_benchmarks/#sugarscape-with-instantaneous-growback","title":"SugarScape with Instantaneous Growback \ud83c\udf6c","text":"<p>View the benchmark script</p> <p></p>"}]}